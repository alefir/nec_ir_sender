# NEC IR SENDER

This is a small project to control an LED strip on my wall using a microcontroller and an infrared LED.

It's meant to work together with a companion phone app acting as a remote.

This project targets the [P-NUCLEO-WB55](https://www.st.com/en/evaluation-tools/p-nucleo-wb55.html) with the STM32WB55 bluetooth-enabled microcontroller from STMicroelectronics.

With the exception of [nec_ir_driver.c](./Core/Src/nec_ir_driver.c) and .h, this is almost entirely autogenerated by STM's STM32CubeIDE and their [SLA0044](www.st.com/SLA0044) license applies.

## How it works

The P-NUCLEO-WB55 uses Bluetooth Low Energy to broadcast and advertise a GATT server. The companion phone app transmits a 1-byte command to the microcontroller, which it then rebroadcasts using the NEC IR protocol to my LED strip.

The BLE event is handled at /STM32\_WPAN/App/p2p\_server\_app.c:35 and the IR rebroadcast is handled by /Core/Src/nec\_ir\_driver.c:36.

### NEC IR Protocol

The OEM remote for my LED strip uses the NEC IR protocol, which Altium provides some [nice documentation](https://techdocs.altium.com/display/FPGA/NEC+Infrared+Transmission+Protocol) for, but here's a quick summary:

A logical 1 is a 562.5us pulse followed by a 562.5us space, and a logical 0 is a 562.5us pulse followed by a 1.6875ms space, both modulated onto a 38.222kHz carrier frequency.

Each code is structured as a 9ms pulse followed by a 4.5ms space, then the address and command, then a 562.5us pulse.

The address section is either an 8-bit address followed by it's logical inverse (for classic NEC) or the lower 8 bits followed by the upper 8 bits of a 16-bit address (for extended NEC).
Because a logical 1 and logical 0 are different lengths of time, the number of each in the address needs to be equal, which limits the extended address space to about 16,000 unique addresses.

The command section is an 8-bit command followed by it's 8-bit logical inverse.

All of the 8-bit sections of the address and command are transmitted least-significant-bit first.

### Broadcasting

The 38.222kHz carrier frequency is generated via PWM through the hardware timer TIM1. It's configured in [MX_TIM1_INIT()](./Core/Src/main.c:302).

The timer increment period is set to 836, and the pulse to 418, which with a 32MHz clock gives us a 38.22kHz pulse with a 50% duty cycle.

PWM Generation is enabled or disabled to send the logical values of the NEC code, and the output of the PWM generator is directly connected to a 940nm IR LED.

### Timing

The HAL driver provided by the manufacturer only provides delay resolution down to integer milliseconds, which is inadequate for the 0.5625 millisecond timing needed for the short pulses of the NEC protocol.

This was solved by using inline assembly to have a simple loop to delay:

```asm
dloop:
	subs r0, r0, #1
	bne dloop
```

Before the number of cycles is put into register r0, the number is divided by three. This comes from a division by 2 due to there being 2 instruction cycles per loop, and a multiplication by 2/3 because
my oscilloscope read all of the timings as 33% too fast without it.

## How I got the codes

I found a github repo claiming to have the IR codes for a very similar LED strip to mine (same remote and a very similar looking controller) but none of the codes worked.

I manually went through all data values from 0 to FF and wrote down what happened to try and match hex values to buttons on the remote. As far as I can tell, the LED controller doesn't actually read the address bytes and only cares about the
data byte, so I hardcoded the lower and upper address bytes to 00 and FF to keep the message length correct.
